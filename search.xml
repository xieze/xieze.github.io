<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[require.js的用法]]></title>
    <url>%2F2017%2F12%2F26%2Frequire-js%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[为什么要用require.js？ 最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。 1&lt;script type="text/javascript" src="1.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>requireJs</category>
      </categories>
      <tags>
        <tag>requireJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你迅速成长甚至成功的，从不是努力]]></title>
    <url>%2F2017%2F12%2F25%2F%E8%AE%A9%E4%BD%A0%E8%BF%85%E9%80%9F%E6%88%90%E9%95%BF%E7%94%9A%E8%87%B3%E6%88%90%E5%8A%9F%E7%9A%84%EF%BC%8C%E4%BB%8E%E4%B8%8D%E6%98%AF%E5%8A%AA%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[让你迅速成长甚至成功的，从不是努力 平均法则的秘密不论是考上重点大学，或是高分通过GRE，是升职加薪谈下大客户，或者自家小生意越发了不起……虽然运气等不可控因素一定存在，但有一个秘密：当你不断重复一件事并达到相当的次数时，平均法则就会发挥效力：「做得越多，水准越高，胜算越大。」那时，你就会对自己的行为效果有大致的判断和把握，而不必完全听天由命靠运气。重复去做，别怕犯错。真正取得了大成就的人，谁不是一路错误中摸爬滚打出来的？如果畏手畏脚，不敢去做，确实不会出错，但也永远不会有喜人成果。 迅速找到正确方向并快速进步不论是学习游泳，打球，或是外语，肢体肌肉，口腔肌肉甚至 “思维肌肉” ，都需要在正确的轨迹与模式上养成习惯，加之刻意练习，才能真正有效地出成绩。比如零基础学习一门外语，最好不要自学。标准发音，基础语法等等，都需要一开始就由老师树一个正确无误的标杆。一旦路走偏，很难不长残。搞不定的话就及时请教。瞎琢磨可能四处碰壁还是探不到出路，浪费自己时间，影响团队效率。 和有能量的一切在一起有人说，你认识的人和你读过的书，塑造了现在这样的你。也有人说，一个人的薪酬水平，约等于周围关系最密切的6个人的平均数。人也好，书也罢，正是因为他们有相当的能量与影响力，才有了今天在他人眼中不一般的地位。请走近并多多学习，一定胜过你眼神空洞头脑空空茫然不知出路在哪里。毕竟取法乎上得其中，取法乎中得其下。还有别忘记 ——觉得已尽力的时候，再多做一点点。如果想要获得大成功，不是非得达成异常高难度的任务，而是将日常普通的任务完成得异于常人地优异。每天多一点，坚持很多天。 集中精力做高价值的事日常中有四类做事形态：以错误的态度做错误的事；以正确的态度做错误的事情；以错误的态度做正确的事；以正确的态度做正确的事。除了4，其它都是人生路上的弯道。明智的做法，是将80％的时间和精力用于去做20%利润高收益大的事情。放弃那些需要大量时间还不确定收益的。那何为 “正确的事” 呢？有天赋的？有兴趣的？有收益的？在我看来，莫过于以上三类的交集。还是那句话：方向不对，努力白费。 犹疑越多，离成功越远很多人经常问，怎样才能大幅提高自己的收入呢？答案就是：立即去做。但为什么绝大多数人都没能充分利用80%的时间投身去做高效创收的事情呢？很重要的原因是： 对失败的担忧与恐惧。而成功者最大的天赋，就是他们拥有让自己立即行动起来的能力。因为他们深谙一个道理：完成比完美更重要。所以你必须明白：行动的最佳时机，就是现在。最好的准备工作，就是放手去做。 困难总是欺软怕硬我想说，比困难本身更能决定成败的，是你对待困难的态度与举措。每一次困难，在常人眼里是放弃的借口，而在成功者眼里，则是成长与锤炼的良机。一直走，路才有。放手去做，迈步去走。形成并不断增大动能，才是克服困难最有效的途径。你逃避困难，殊不知，有人克服了一个困难后会主动寻求更大的困难，以此不断训练自己战胜困难的勇气与能力。也许你会说：变态啊，自讨苦吃好累～ 累才说明，你的人生正在走上坡路啊。我知道生活不易，也知道你很辛苦。但，辛苦是最不值得一提的付出。不要讲述你的辛苦，也不要觉得你很努力，首先，你要找对方向。]]></content>
      <categories>
        <category>励志</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript墨卡托经纬度互转]]></title>
    <url>%2F2017%2F12%2F11%2Fjavascript%E5%A2%A8%E5%8D%A1%E6%89%98%E7%BB%8F%E7%BA%AC%E5%BA%A6%E4%BA%92%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[墨卡托投影是荷兰地理学家墨卡托于1569年提出的一种地球投影方法，该方法是圆柱投影的一种。 1234567891011121314151617181920212223242526272829/** * 经纬度转墨卡托 * @param poi 经纬度 * @returns &#123;&#123;&#125;&#125; * @private */function _getMercator(poi) &#123;//[114.32894, 30.585748] var mercator = &#123;&#125;; var earthRad = 6378137.0; // console.log("mercator-poi",poi); mercator.x = poi.lng * Math.PI / 180 * earthRad; var a = poi.lat * Math.PI / 180; mercator.y = earthRad / 2 * Math.log((1.0 + Math.sin(a)) / (1.0 - Math.sin(a))); // console.log("mercator",mercator); return mercator; //[12727039.383734727, 3579066.6894065146]&#125;/** * 墨卡托转经纬度 * @param poi 墨卡托 * @returns &#123;&#123;&#125;&#125; * @private */function _getLngLat(poi)&#123; var lnglat = &#123;&#125;; lnglat.lng = poi.x/20037508.34*180; var mmy = poi.y/20037508.34*180; lnglat.lat = 180/Math.PI*(2*Math.atan(Math.exp(mmy*Math.PI/180))-Math.PI/2); return lnglat;&#125;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[curl命令]]></title>
    <url>%2F2017%2F12%2F06%2Fcurl%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[curl是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在”标准输出”（stdout）上面。它支持多种协议，下面举例讲解如何将它用于网站开发。 查看网页源码直接在curl命令后加上网址，就可以看到网页源码。我们以网址www.sina.com为例（选择该网址，主要因为它的网页代码较短）：12345678910 $ curl www.sina.com &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt;301 Moved Permanently&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h1&gt;Moved Permanently&lt;/h1&gt; &lt;p&gt;The document has moved &lt;a href=&quot;http://www.sina.com.cn/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;如果要把这个网页保存下来，可以使用`-o`参数，这就相当于使用wget命令了。 $ curl -o [文件名] www.sina.com 自动跳转有的网址是自动跳转的。使用-L参数，curl就会跳转到新的网址。1$ curl -L www.sina.com 键入上面的命令，结果就自动跳转为www.sina.com.cn。 显示头信息-i参数可以显示http response的头信息，连同网页代码一起。1234567891011121314151617181920 $ curl -i www.sina.com HTTP/1.0 301 Moved Permanently Date: Sat, 03 Sep 2011 23:44:10 GMT Server: Apache/2.0.54 (Unix) Location: http://www.sina.com.cn/ Cache-Control: max-age=3600 Expires: Sun, 04 Sep 2011 00:44:10 GMT Vary: Accept-Encoding Content-Length: 231 Content-Type: text/html; charset=iso-8859-1 Age: 3239 X-Cache: HIT from sh201-9.sina.com.cn Connection: close &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt;301 Moved Permanently&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h1&gt;Moved Permanently&lt;/h1&gt; &lt;p&gt;The document has moved &lt;a href=&quot;http://www.sina.com.cn/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; -I参数则是只显示http response的头信息。四、显示通信过程-v参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。123456789101112131415161718192021222324252627282930 $ curl -v www.sina.com * About to connect() to www.sina.com port 80 (#0) * Trying 61.172.201.195... connected * Connected to www.sina.com (61.172.201.195) port 80 (#0) &gt; GET / HTTP/1.1 &gt; User-Agent: curl/7.21.3 (i686-pc-linux-gnu) libcurl/7.21.3 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18 &gt; Host: www.sina.com &gt; Accept: */* &gt; * HTTP 1.0, assume close after body &lt; HTTP/1.0 301 Moved Permanently &lt; Date: Sun, 04 Sep 2011 00:42:39 GMT &lt; Server: Apache/2.0.54 (Unix) &lt; Location: http://www.sina.com.cn/ &lt; Cache-Control: max-age=3600 &lt; Expires: Sun, 04 Sep 2011 01:42:39 GMT &lt; Vary: Accept-Encoding &lt; Content-Length: 231 &lt; Content-Type: text/html; charset=iso-8859-1 &lt; X-Cache: MISS from sh201-19.sina.com.cn &lt; Connection: close &lt; &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt;301 Moved Permanently&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h1&gt;Moved Permanently&lt;/h1&gt; &lt;p&gt;The document has moved &lt;a href=&quot;http://www.sina.com.cn/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; * Closing connection #0 如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。1 $ curl --trace output.txt www.sina.com 或者1 $ curl --trace-ascii output.txt www.sina.com 运行后，请打开output.txt文件查看。 发送表单信息发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。1 $ curl example.com/form.cgi?data=xxx POST方法必须把数据和网址分开，curl就要用到–data参数。1 $ curl -X POST --data &quot;data=xxx&quot; example.com/form.cgi 如果你的数据没有经过表单编码，还可以让curl为你编码，参数是--data-urlencode。1 $ curl -X POST--data-urlencode &quot;date=April 1&quot; example.com/form.cgi HTTP动词curl默认的HTTP动词是GET，使用-X参数可以支持其他动词。12$ curl -X POST www.example.com$ curl -X DELETE www.example.com 文件上传假定文件上传的表单是下面这样：1234 &lt;form method=&quot;POST&quot; enctype=&apos;multipart/form-data&apos; action=&quot;upload.cgi&quot;&gt; &lt;input type=file name=upload&gt; &lt;input type=submit name=press value=&quot;OK&quot;&gt; &lt;/form&gt; 你可以用curl这样上传文件：1 $ curl --form upload=@localfilename --form press=OK [URL] Referer字段有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。1 $ curl --referer http://www.example.com http://www.example.com User Agent字段这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。iPhone4的User Agent是1 Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7 curl可以这样模拟：1 $ curl --user-agent &quot;[User Agent]&quot; [URL] cookie使用--cookie参数，可以让curl发送cookie。1 $ curl --cookie &quot;name=xxx&quot; www.example.com 至于具体的cookie的值，可以从http response头信息的Set-Cookie字段中得到。-c cookie-file可以保存服务器返回的cookie到文件，-b cookie-file可以使用这个文件作为cookie信息，进行后续的请求。12 $ curl -c cookies http://example.com $ curl -b cookies http://example.com 增加头信息有时需要在http request之中，自行增加一个头信息。--header参数就可以起到这个作用。1 $ curl --header &quot;Content-Type:application/json&quot; http://example.com HTTP认证有些网域需要HTTP认证，这时curl需要用到--user参数。1 $ curl --user name:password example.com 参考资料：curl网站开发指南]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime非常好用的文件对比插件--sublimerge]]></title>
    <url>%2F2017%2F12%2F06%2Fsublime%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%AF%B9%E6%AF%94%E6%8F%92%E4%BB%B6--sublimerge%2F</url>
    <content type="text"><![CDATA[Sublimerge还不是Sublime Text的另一个 diff插件。事实上，它是最先进，功能最齐全的插件，将您最喜爱的编辑器变成专业的并排比较和合并工具，具有惊人的功能！ 安装插件如果Sublime安装了Package Control,直接Command+Shift+P(Mac下)输入 sublimerge，搜索到点击即可自行安装，不需重启sublime。 使用插件在sublime下都打开要对比的两个文件，在其中一个文件中，右击，选择“sublimerge”–&gt;&gt;”Compare to *“选择要对比的文件 总结另外未保存对比也是挺有意思的功能，有时候会忘记自己修改了哪里，右击，选择”show unsaved changes“ 参考资料： sublimerge官网]]></content>
      <categories>
        <category>sublime</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublimeText下好用的markdown插件与快捷键]]></title>
    <url>%2F2017%2F12%2F06%2FsublimeText%E4%B8%8B%E5%A5%BD%E7%94%A8%E7%9A%84markdown%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[关于安装：如果Sublime安装了Package Control,直接Command+Shift+P(Mac下)输入 MarkdownEditing，搜索到点击即可自行安装，重启便可使用。 关于特性：MarkdownEditing 从视觉和便捷性上针对 Markdown 文档的编辑进行了一系列的优化。具体如下(Mac下)：安装后针对 md\mdown\mmd\txt 格式文件启用插件。颜色方案仿 Byword及iA writer。自动匹配星号（*）、下划线（_）及反引号（），选中文本按下以上符号能自动在所选文本前后添加配对的符号，方便粗体、斜体和代码框的输入。 直接输入配对的符号后按下退格键（backspace`），则两个符号都会被删除；直接输入配对的符号后按下空格键，则会自动删除后一个。对“选中文字后输入左括号”这一动作进行了调整，以便插入markdown链接。拷贝一个链接，选中文本后按下 ⌘⌥V 会自动插入内联链接。拷贝一个链接，选中文本后按下 ⌘⌥R 会自动插入引用链接。⌘⌥K 插入链接；⌘⇧K 插入图片。⌘⇧B 和 ⌘⇧I 分别用于加粗体和斜体。⌘^1..6 对于选中的内容前加对应个数#,即对选中内容字体大小设置为h1~h6;⌘⇧6插入文档脚注并且跳转到它的定义；具体可参见:Footnotes;选中文本后按下 # 会自动在文本前后进行配对，可重复按下来定义标题级别。 关于配置:有些快捷键可能与系统的一些发生冲突，可以编辑 ~/Library/Application Support/Sublime Text/Packages/MarkdownEditing/Default (OSX).sublime-keymap 改掉。另外还有一些设置可以在 ~/Library/Application Support/Sublime Text 2/Packages/MarkdownEditing/Markdown.sublime-settings 中进行修改。比如除了默认的颜色主题外，MarkdownEditing 还提供了一个高亮显示编辑行 MarkdownEditor-Focus，就可以在 Markdown.sublime-settings 这个文件中找到并去掉注释保存生效。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Sublime Text 3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF攻击与防御原理]]></title>
    <url>%2F2017%2F12%2F05%2FCSRF%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[CSRF是什么？ （Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一,也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用也就是人们所知道的钓鱼网站。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 CSRF可以做什么？你这可以这么理解 CSRF 攻击：攻击者盗用了你的身份，伪装成你发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 它这么厉害，那它的原理是什么？ 通过下图来简述原理登录受信任网站A，并在本地生成Cookie。在不登出A的情况下，访问危险网站B。看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 详细的原理介绍 几种常见的攻击类型 GET类型的CSRF 这种类型的CSRF一般是由于程序员安全意识不强造成的。GET类型的CSRF利用非常简单，只需要一个HTTP请求，所以，一般会这样利用： 1&lt;img src=http://wooyun.org/csrf?xx=11 /&gt; 在访问含有这个img的页面后，成功向http://wooyun.org/csrf?xx=11 发出了一次HTTP请求。所以，如果将该网址替换为存在GET型CSRF的地址，就能完成攻击了。 乌云案例 POST类型的CSRF 这种类型的CSRF危害没有GET型的大，利用起来通常使用的是一个自动提交的表单，如： 1234&lt;form action=http://wooyun.org/csrf.php method=POST&gt; &lt;input type="text" name="xx" value="11" /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。 乌云案例 其他其他猥琐流CSRF 过基础认证的CSRF(常用于路由器): POC: 1&lt;img src=http://admin:admin@192.168.1.1 /&gt; 加载该图片后，路由器会给用户一个合法的SESSION，就可以进行下一步操作了。乌云案例 防御CSRF的策略在业界目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。下面就分别对这三种策略进行详细介绍。 验证 HTTP Referer 字段根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。因此，要防御 CSRF 攻击，网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 网站支持IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。 在请求地址中添加 token 并验证CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 &lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。 在 HTTP 头中自定义属性并验证这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。 防御实例Sailajs框架中的JavaScript 代码示例 下面将以 JavaScript 为例，对上述三种方法分别用代码进行示例。 1.验证 Referer12345678// 从 HTTP 头中取得 Referer 值 var referer=req.headers.Referer; // 判断 Referer 是否以 test.example 开头 if((referer!=null) &amp;&amp; (_.startsWith(referer, “test.example ”))&#123; // 验证通过 &#125;else&#123; // 验证失败，返回错误 &#125; 2.验证请求中的 token 1234567891011121314151617181920212223242526272829303132333435363738 var session = req.session; // 从 session 中得到 csrftoken 属性 var token = session.csrftoken; if(token == null)&#123; // 产生新的 token 放入 session 中 token = generateToken(); token.csrftoken = token ; return .... &#125; else&#123; // 从 HTTP 头中取得 csrftoken var token = req.headers.csrftoken; // 从请求参数中取得 csrftoken var xhrToken = req.param('csrftoken'); if(token != null &amp;&amp; xhrToken != null &amp;&amp; token.equals(xhrToken))&#123; return ... &#125;else&#123; return ... // ERROR &#125; &#125;HTTP 头中自定义属性(网上例子)var plainXhr = dojo.xhr; // 重写 dojo.xhr 方法 dojo.xhr = function(method,args,hasBody) &#123; // 确保 header 对象存在 args.headers = args.header || &#123;&#125;; tokenValue = '&lt;%=request.getSession(false).getAttribute("csrftoken")%&gt;'; var token = dojo.getObject("tokenValue"); // 把 csrftoken 属性放到头中 args.headers["csrftoken"] = (token) ? token : " "; return plainXhr(method,args,hasBody); &#125;; 总结 CSRF 是一种危害非常大的攻击，又很难以防范。目前几种防御策略虽然可以很大程度上抵御 CSRF 的攻击，但并没有一种完美的解决方案。一些新的方案正在研究之中，比如对于每次请求都使用不同的动态口令，把 Referer 和 token 方案结合起来，甚至尝试修改 HTTP 规范，但是这些新的方案尚不成熟，要正式投入使用并被业界广为接受还需时日。在这之前，我们只有充分重视 CSRF，根据系统的实际情况选择最合适的策略，这样才能把 CSRF 的危害降到最低]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>csrf</tag>
      </tags>
  </entry>
</search>
